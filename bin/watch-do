#!/usr/bin/env tclsh
# Process watches on fossil repositories

# # ## ### ##### ######## ############# ######################

package require Tcl 8.5
package require sqlite3
package require http
package require tdom
package require struct::matrix
package require textutil::adjust

package require tls
package require smtp
package require mime

# # ## ### ##### ######## ############# ######################

proc main {} {
    do {*}[cmdline]
    return
}

proc cmdline {} {
    global argv
    if {[llength $argv] != 0} { usage }

    #lassign $argv
    return $argv
}

proc usage {} {
    global argv0
    puts stderr "Usage: $argv0"
    exit 1
}

# # ## ### ##### ######## ############# ######################

proc dbfile {} {
    set f ~/.fossil.watch
    return $f
}

proc seen {artifactid} {
    return [DB onecolumn {
	SELECT count(*)
	FROM   seen
	WHERE  hash = :artifactid
    }]
}

proc see {pid artifactid} {
    puts "  Seen $artifactid / disabled - DRY"
    #return ;# TODO; remove, to enable
    DB eval {
	INSERT INTO seen VALUES (NULL, :pid, :artifactid)
    }
    return
}

proc config {k} {
    # TODO: Move this information into the ~./.fossil.ewatch state
    #       file, and create tools to show and/or modify it.

    dict get {
	debug    0
        tls      0
	user     {}
	password {}
	host     localhost
	port     25
    } $k 
    # port 465 for tls
}

# # ## ### ##### ######## ############# ######################

proc do {} {
    set watch [dbfile]
    if {![file exists $watch]} {
	puts "No watches defined (no database)"
	return
    }

    sqlite3 DB $watch

    # Iterate over all projects.
    DB eval {
	SELECT P.pid        AS pid,
	       P.repository AS url,
	       P.sendermail AS src
	FROM project P
	ORDER BY url
    } {
	do-project $pid $url $src
    }

    return
}

proc do-project {pid url sender} {

    puts "Repository $url ..."

    set receivers [DB eval {
	    SELECT R.mail AS dst
	    FROM   project_receiver PR,
	           receiver R
	    WHERE PR.pid = :pid
	    AND   R.rid = PR.rid
	    ORDER BY dst
    }]

    if {![llength $receivers]} {
	puts "Skipped (no receivers)"
	return
    }

    foreach artifact [process-timeline [get-timeline $url]] {
	process-artifact \
	    [get-artifact $url $artifact] \
	    [list send-mail $url $sender $receivers $artifact]
	see $pid $artifact
    }

    puts "Done\n"
    return
}

proc process-artifact {manifest cmd} {
    # changed fields
    set field {}
    set stamp unknown

    foreach line [split $manifest \n] {
	if {[regexp {^J (.*) (.*)$} $line -> fname value]} {
	    dict set field $fname [dearmor $value]
	    continue
	}
	if {[regexp {^K (.*)$} $line -> ticket]} {
	    continue
	}
	if {[regexp {^D (.*)$} $line -> stamp]} {
	    continue
	}
    }

    if {![info exists ticket] || ![dict size $field]} {
	puts "    Not a ticket change"
	return
    }

    {*}$cmd $ticket $stamp $field
    return
}

proc get-timeline {url} {
    puts "  Timeline ..."
    get $url/timeline.rss?type=t&n=200
    # Note: type filtering seems to broken.
}

proc get-artifact {url artifact} {
    puts "\n  Artifact $artifact ..."
    get $url/raw?name=$artifact
}

# # ## ### ##### ######## ############# ######################
## http retrieval helper

proc get {url} {
    set token [http::geturl $url]
    if {[http::ncode $token] != 200} {
	puts "Fail: [http::ncode $token] [http::error $token]"
	http::cleanup $token
	return {}
    }

    set data [http::data $token]
    http::cleanup $token
    return $data
}

# # ## ### ##### ######## ############# ######################
## SAX parse timeline RSS

proc process-timeline {rss} {
    variable alist {}

    xml::parser theparser -namespace -final 1 \
	-elementstartcommand  start-element \
	-characterdatacommand char-data \
	-elementendcommand    end-element

    variable tree ROOT
    theparser parse $rss
    rename theparser {}
    # collected information

    #traverse ROOT 0
    return $alist
}

# # ## ### ##### ######## ############# ######################
## SAX parsing callbacks.

proc start-element {name attributes} {
    variable kids
    variable tree
    variable chardata
    set chardata {}
    dict set kids $tree [lappend tree $name] {}
    # # ## ### ##### ######## #############
    ## Bespoke processing
    # # ## ### ##### ######## #############
    return
}

proc char-data {data} {
    variable chardata
    append chardata $data
    return
}

proc end-element {name} {
    variable tree
    variable chardata
    # # ## ### ##### ######## #############
    ## Bespoke processing
    contextmatch {
	{rss channel item link} {
	    # chardata = link
	    # ignore anything but /info/...
	    # ignore already seen artifacts as well.
	    if {
		[regexp {/info/(.*)$} $chardata -> artifact] &&
		![seen $artifact]
	    } {
		puts "  New: $artifact"
		variable alist
		lappend  alist $artifact
	    }
	}
    }
    # # ## ### ##### ######## #############
    set tree [lrange $tree 0 end-1]
    return
}

# # ## ### ##### ######## ############# ######################
## SAX support

proc contextmatch {what} {
    variable tree
    set l [expr {[llength $tree] - 1}]
    foreach {pattern script} $what {
	set i [expr {[llength $pattern] - 1}]
	if {$i <= $l} {
	    set ok 1
	    for {set j $l} {$ok && $i >= 0} {incr i -1; incr j -1} {
		if {[lindex $pattern $i] ne [lindex $tree $j]} {
		    set ok 0
		}
	    }
	    if {$ok} {
		uplevel 1 $script
	    }
	}
    }
}

proc traverse {name level} {
    variable kids
    puts [format %*s%s [expr {4 * $level}] {} $name]
    incr level
    if {[dict exists $kids $name]} {
	foreach k [dict keys [dict get $kids $name]] {
	    traverse $k $level
	}
    }
}

# # ## ### ##### ######## ############# ######################

proc send-mail {url sender receivers artifact ticket stamp fields} {
    set corpus  [generate-mail $url $artifact $ticket $stamp $fields]
    set project [lindex [split $url /] end]

    set tshort [string range $ticket   0 7]
    set ashort [string range $artifact 0 7]

    set subject "\[$project\] (Ticket $tshort) Change $ashort"

    # NOTE: To get the ticket title this code has to manage a local
    #       clone of the tracked repository for direct access to the
    #       ticket tables.
    #
    #       Assuming that the ticket setup has a title field.
    #       ==> Field to use could be a configuration entry.

    puts "    ================================================"
    puts [textutil::adjust::indent $corpus {        }]
    puts "    ================================================"

    set token [mime::initialize -string $corpus]

    foreach dst $receivers {
	puts "    To: $dst"

	lappend config -header    [list To      $dst]
	lappend config -header    [list From    $sender]
	lappend config -header    [list Subject $subject]

	lappend config -debug     [config debug]
	lappend config -usetls    [config tls]
	lappend config -tlspolicy tls-policy
	lappend config -username  [config user]
	lappend config -password  [config password]
	lappend config -servers   [list [config host]]
	lappend config -ports     [config port]

	set res [smtp::sendmessage $token {*}$config]
	foreach item $res {
	    puts "    ERR $item"
	}

	unset config
    }

    mime::finalize $token
    puts "    Sent"
    return
}

proc tls-policy {args} {
    puts $args
    return secure
}

proc generate-mail {url artifact ticket stamp fields} {

    # NOTE: Mail is currently pure text.
    # Maybe make this a multipart/mixed ? text + html).
    # We can pull the HTML for the ticket directly from the repository
    # (see ticket url below) include that.  Easy, and automatically
    # follows any layout changes/differences we may do to the
    # repository.

    lappend lines $url
    lappend lines ""
    lappend lines "Change Notification For"
    lappend lines "  Ticket   $url/tktview?name=$ticket"
    lappend lines "  Artifact $artifact"
    lappend lines "  On       $stamp"
    lappend lines ""

    struct::matrix M
    M add columns 2
    foreach f [lsort -dict [dict keys $fields]] {
	set v [dict get $fields $f]
	# Special handling...
	switch -exact -- $f {
	    icomment { set v [reformat $v] }
	    mimetype {
		continue ;# = ignore this field
	    }
	    default  { }
	}
	M add row [list ${f}: $v]
    }

    if {[M rows]} {
	lappend lines "Changed Fields"
	lappend lines [textutil::adjust::indent \
			   [M format 2string] \
			   {  }]
	lappend lines ""
    }
    M destroy

    return [join $lines \n]
}

# # ## ### ##### ######## ############# ######################
## Dearmor fossil strings

set dearmor [list \\s { } \\n \n \\t \t \\r \r]
proc dearmor {s} {
    variable    dearmor
    string map $dearmor $s
}

proc reformat {s} {
    # split into paragraphs. may contain sequences of
    # empty paragraphs.
    set paragraphs {}
    set p {}
    foreach l [split $s \n] {
	if {[string trim $l] eq {}} {
	    lappend paragraphs $p
	    set p {}
	} else {
	    append p $l\n
	}
    }
    lappend paragraphs $p

    # format paragraphs, ignoring empty ones.
    set s {}
    foreach p $paragraphs {
	if {$p eq {}} continue
	append s [textutil::adjust::adjust $p \
		      -strictlength 1 \
		      -length       70] \n\n
    }

    # done
    return [string trimright $s]
}

# # ## ### ##### ######## ############# ######################

main
exit
